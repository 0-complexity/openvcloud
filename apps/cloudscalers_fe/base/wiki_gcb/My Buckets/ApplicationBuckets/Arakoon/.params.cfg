appname=Arakoon
appdescription=A key value store allows you to store values by key, as simple as that. The value can be files like text, images or other objects. A key-value store is intended to store relatively small objects (size < 1M) and key-value stores are easier to configure on a per-application basis. As far as the data store is concerned, it just stores it, it doesn’t actually care about the content. In other words, we don’t have a data stored defined schema, but a client defined semantics for understanding what the values are. The benefits of using this approach is that it is very simple to build a key value store, and that it is very easy to scale it. It also tend to have great performance, because the access pattern in key value store can be heavily optimized. Reliability at massive scale is one of the biggest challenges in IT. When running a pltform, even the slightest outage can have significant financial consequences and impacts customer trust. A typical database system cannot provide enough reliability to scale on top of an infrastructure of tens of thousands of servers and network components located in many datacenters around the world. At this scale, small and large components fail continuously and will not scale. Traditional replicated relational database systems focus on the problem of guaranteeing strong consistency to replicated data. Although strong consistency provides the application writer a convenient programming model, these systems are limited in scalability and availability. These systems are not capable of handling network partitions because they typically provide strong consistency guarantees.
appurl=www.arakoon.org
appprice=100
defaultlogin=root
defaultpassword=rooter
appfeature1=* Highly available consistent distributed key-value storage system:
appfeature2=* Consistency: The system as a whole needs to provide a consistent view on the distributed state. This stems from the experience that eventual consistency is too heavy a burden for a user application to manage.
appfeature3=* A simple example is the retrieval of the value for a key where you might receive none, one or multiple values depending on the weather conditions. The next question is always: Why don’t a get a result? Is it because there is no value, or merely because I currently cannot retrieve it?
appfeature4=* Distributed: Our KeyValueStor does not use any centralized server and can like this achieves high availability and scalability using replication.
appfeature5=* Conditional and Atomic Updates: We don’t need full blown transactions, but we do need updates that abort if the state is not what we expect it to be. So at least an atomic conditional update and an atomic multi-update are needed.
appfeature6=* Robustness: The system must be able to cope with failure of individual components, without concessions to consistency.
appfeature7=* However, whenever consistency can no longer be guaranteed, updates must simply fail.
appfeature8=* Locality Control: When we deploy a system over 2 datacenters, we want guarantees that the entire state is indeed present in both datacenters. This is something we could not get from distributed hash tables using consistent hashing.
appfeature9=* Healing & Recovery: Whenever a component dies and is subsequently revived or replaced, the system must be able to guide that component towards a situation where that node again fully participates. If this cannot be done fully automatically, then human intervention should be trivial.
appfeature10=* Explicit Failure: Whenever there is something wrong, failure should propagate quite quickly. This in contrast to systems that keep on trying to remedy the situation themselves all the time.
